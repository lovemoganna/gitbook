{"./":{"url":"./","title":"practice skill","keywords":"","body":"Introduction Fight Master all right reserved，powered by GitbookLatest Update 2020-06-03 15:28:18 "},"webpack/webpack-concept/":{"url":"webpack/webpack-concept/","title":"webpack concept","keywords":"","body":"webpack webpack 基本概念 Fight Master all right reserved，powered by GitbookLatest Update 2020-06-06 11:44:55 "},"webpack/webpack-concept/1-entry.html":{"url":"webpack/webpack-concept/1-entry.html","title":"1.1 entry","keywords":"","body":"Entry Entry 属性,有多种方式来定义. :smiley: Single Entry{速记} 语法 Usage: entry: string | [string] module.exports = { entry: './path/to/my/entry/file.js' }; 对于 entry 属性 ,单个 entry 语法可简记为: module.exports = { entry: { main: './path/to/my/entry/file.js' } }; 当你给 entry 传递数组的时候会发生什么? 在给 entry 属性 传递一个文件路径数组过程中,会创建视为 multi-main entry. 当你想一起注入多个依赖文件,并且图形化它们的依赖到一个 chunk (组块)当中,这是非常有用的. 这个方式并不是特别灵活. Object Syntax Usage: entry: { string | [string] } //webpack.config.js //-------------------------------------------- module.exports = { entry: { app: './src/app.js', adminApp: './src/adminApp.js' } }; 这个 object syntax 更加冗余,但这是在应用中定义 entry/entries 最具拓展性的方式. Scalable webpack configuration 是一种可以重用和包含其他不完整的配置. 这是一种受欢迎的技术,通过 environment / build target/ runtime 被用于分离关注事项.他们也可以通过特殊工具来合并起来,比如使用 webpack-merge. Scenarios(情境) Separate APP and Vendor(供应商) Entries 这主要有 3个文件 webpack.config.js module.exports = { entry: { main: './src/app.js', vendor: './src/vendor.js' } }; webpack.prod.js (生产环境的配置)module.exports = { output: { filename: '[name].[contentHash].bundle.js' } }; webpack.dev.js (开发环境的配置)module.exports = { output: { filename: '[name].bundle.js' } }; 现在的情况就是,我们告诉webpack. 有2个分离的入口点,为毛这么干哪, JS里面有很多库,妈的,有些库你不必管它. 给你弄个 threeJS 的库,估计每个10天半个月也看不懂.所以把这些库看成死物.放在 vendor.js 里面就可以了. 它们将会捆绑在一起,然后放到它们的(组块) chunk当中. -content hash 是一样的,允许浏览器单独缓存它们,从而减少载入的时间. main: app.js vendor: vendor.js // 放一些 JQUERY/THREEJS/BOOTSTRAP 的库. webpack4 版本以下,通常添加 vendor 作为 separate entry point 来编译它作为 separate file.(与 CommonsChunkPlugin 相结合). webpack4 不建议这么做, optimization.splitChunks option 关心 separating vendors and app modules, AND creating a separate file. 所以不必为一个vendors 或其他东西 创建一个 entry了,这也不是执行操作的起点. Multi Page Application module.exports = { entry: { pageOne: './src/pageOne/index.js', pageTwo: './src/pageTwo/index.js', pageThree: './src/pageThree/index.js' } }; 这样就是告诉 webpack 我们想有 3个分离的依赖图示. 在单页面应用中,服务器在为你 fetch 一个新的 HTML document过程中,这个页面会重载新的 document ,assets会被重新下载. 这给我们唯一的选择来做这件事情,比如说使用 optimization.splitChunks 来创建捆绑包,从而在每个页面间的分享应用代码. Multi-Page 应用随着 entry point 的数量增加,可以在 entry point 之间可以重复使用大量的代码 和 模块,受到了这项技术的巨大益处. Fight Master all right reserved，powered by GitbookLatest Update 2020-06-03 15:28:18 "},"webpack/webpack-concept/2-output.html":{"url":"webpack/webpack-concept/2-output.html","title":"1.2 output","keywords":"","body":"Output 配置 output 属性就是告诉 webpack 如何写编译好的文件输出到磁盘. 注意,尽管可以设置多个entry point,但是仅可以有一个 ouput 被指定. Usage 最小配置如下: module.exports = { output: { filename: 'bundle.js', } }; Multiple Entry Points 如果你配置创建了多个 chunk (因为携带了多个 entry point 或者当你使用 plugins ,比如 CommonsChunkPlugin 的时候). 你应该使用 substitution (替换) 来确保每个文件都有一个独一无二的名字. module.exports = { entry: { app: './src/app.js', search: './src/search.js' }, output: { filename: '[name].js', path: __dirname + '/dist' } }; // writes to disk: ./dist/app.js, ./dist/search.js Advanced 下面是对 assets使用CND 和 hashes的例子. // config.js // ------------------------------ module.exports = { output: { path: '/home/proj/cdn/assets/[hash]', publicPath: 'https://cdn.example.com/assets/[hash]/' } }; 在编译时间过程中, outputfile 的 最终 publicPath 不知道的情况下, pubilcPath 能空着并且动态设置. __webpack_public_path__ = myRuntimePublicPath; // 其余的应用入口 Fight Master all right reserved，powered by GitbookLatest Update 2020-06-03 15:28:18 "},"webpack/webpack-concept/3-loaders.html":{"url":"webpack/webpack-concept/3-loaders.html","title":"1.3 loaders","keywords":"","body":"Loaders Loaders 是一个转换器.被应用在一个模块的源代码上. 它们允许你 预处理 pro-process 文件作为你 import or load them. 因此, loaders 是一个像 处理 前端构建步骤的 \"tasks\". Loaders 可以转换来自不同语言的 files 成为JS.也可以载入内联图片作为 data URLS. Loaders 甚至允许你做一些事情,比如: 直接从你的JS模块里面 import CSS files. Example 可以告诉webpack 载入 css 文件,或者转换typescript 成为 JavaScript. 要想做这个你得先安装loaders. npm install --save-dev css-loader ts-loader 然后,就会通知webpack 对每个 .css 文件来使用 css-loader 了. 这种的话,需要写规则. //webpack.config.js //------------------------------------------ module.exports = { module: { rules: [ { test: /\\.css$/, use: 'css-loader' }, { test: /\\.ts$/, use: 'ts-loader' } ] } }; Using Loaders 有3个法来使用loaders. Configuration: 直接在 webpack.config.js 里面配置就可以. Inline: 这种的话,需要在每个 import 声明中明确指定. CLI: 命令行操作. Configuration module.rules 允许你在你的webpack配置当中 指定一些loaders. 这是一种展示 loaders的简式方法,可以帮助你维护干净的代码.它也为你提供了各个loader的全部预览. Loaders 从右到左/从下到上 被评估/执行, 比如,先从 sass-loader,继续从 css-loader 执行,最终是 style-loader . module.exports = { module: { rules: [ { test: /\\.css$/, use: [ // style-loader { loader: 'style-loader' }, // css-loader { loader: 'css-loader', options: { modules: true } }, // sass-loader { loader: 'sass-loader' } ] } ] } }; INLINE and CLI 的模式先不用了.没必要搞个麻烦的例子. Resolving Loaders loaders 使用 npm 来管理. Fight Master all right reserved，powered by GitbookLatest Update 2020-06-03 15:28:18 "},"webpack/webpack-concept/4-plugins.html":{"url":"webpack/webpack-concept/4-plugins.html","title":"1.4 plugins","keywords":"","body":"Plugins Plugin 是 webpack里面的骨干. Anatomy(解析) webpack plugin 是一个 JS 对象,运用 apply 方法. 这个apply方法在webpack编译的时候被调用,给予整个编译生命周期的访问. ConsoleLogOnBuildWebpackPlugin.js Usage 因为plugin 可以携带 arguments/options,你必须给 plugins 属性传递一个新的实例. Configuration const HtmlWebpackPlugin = require('html-webpack-plugin'); //installed via npm const webpack = require('webpack'); //to access built-in plugins const path = require('path'); module.exports = { entry: './path/to/my/entry/file.js', output: { filename: 'my-first-webpack.bundle.js', path: path.resolve(__dirname, 'dist') }, module: { rules: [ { test: /\\.(js|jsx)$/, use: 'babel-loader' } ] }, plugins: [ new webpack.ProgressPlugin(), new HtmlWebpackPlugin({template: './src/index.html'}) ] }; NODE API Using plugin configuration it. Fight Master all right reserved，powered by GitbookLatest Update 2020-06-03 15:28:18 "},"webpack/webpack-concept/5-configuration.html":{"url":"webpack/webpack-concept/5-configuration.html","title":"1.5 configuration","keywords":"","body":"Configuration 这个配置是通过webpack基于它的定义属性来处理的. 因为它是标准的 Nodejs commonjs 模块.你可以做: import other file, using require (...) use utilities on npm use js control flow expressions, eg. the ?: operator. use constants or variables for often used values. write and execute functions to generate a part of the configuration 其余的配置选项： simple configuration Multiple configuration Using other Configuration Languages typescript coffeescript Babel JSX Fight Master all right reserved，powered by GitbookLatest Update 2020-06-03 15:28:18 "},"webpack/webpack-concept/6-modules.html":{"url":"webpack/webpack-concept/6-modules.html","title":"1.6 modules","keywords":"","body":"Modules 模块化编程的一些基础概念. What is a webpack module 相比较 NODEJS 模块,webpack 模块可以表示他们的依赖. ES2015 import 声明 Commonjs require 声明 AMD define and require 声明 在 css/sass/less file里面的 @import 声明 样式表中的 image URL ,like url(...) 或者 HTML里面的 …>= file. Supported module types 预处理器. CoffeeScript TypeScript ESNext Sass Less Stylus Elm Fight Master all right reserved，powered by GitbookLatest Update 2020-06-03 15:28:18 "},"webpack/webpack-concept/7-module-resolution.html":{"url":"webpack/webpack-concept/7-module-resolution.html","title":"1.7 module-resolution","keywords":"","body":"module resolution 一个解析器是一个库.通过绝对路径来定位模块. import foo from 'path/to/module'; // or require('path/to/module'); 这个依赖模块可能来自应用代码,也可能来自第三方库. 解析器帮助webpack发现模块的代码,对于每一个 require/import 声明需要被包含在捆绑包当中. 在捆绑模块的时候,webpack 使用 enhanced-resolve 来解析文件路径 resolving rules in webpack Using enhanced-resolve , webpack可以解析三种类型的文件路径. Absolute Paths import '/home/me/file'; import 'C:\\\\Users\\\\me\\\\file'; Relative Paths import '../src/file1'; import './file2'; Module paths import 'module'; import 'module/lib/file'; 模块会搜索 所有由 resolve.modules 指定的目录. 你可以替换 origin module 路径,只需要通过一个备用路径: 使用 resolve.alias 配置选项创建一个alias. 一旦路径基于上面的规则被解析,解析器会检查看这个 path point 是一个文件还是目录,如果 path point 是一个文件: 如果path 是一个文件扩展,那这个文件会直接被捆绑. 如果这个 file extension 使用 resolve.extension 选项来进行解析,这将告诉解析器,这个 extensions 被解析过程所认同.比如说: .js /.jsx 如果 path point 是一个文件夹,下面的一步一步是在正确的extension中发现正确的file. 如果folder包含一个 package.json 文件,接下来这个字段通过指定=resolve.mainfields= 配置选项来有序查看,第一个字段 package.json 明确文件路径. 如果没有 package.json 文件,或者 resolve.mainField 没能返回一个有效的路径, resolve.mainFiles 配置选项中指定的file name会被有序查看, 主要看下 importted/required 的目录里,正在匹配的文件名是否存在. file extension 以同样的方式使用 resolve.extensions 选项被解析. webpack 根据你的构建对象提供合理的选项. Resolving Loaders 对文件解析的同种规则也是由其所指定.但是 这个 resolveLoader 配置选项可以对 loaders 用于分离解析规则. Caching 每一个文件系统的访问被缓存,所以对同一个文件的多个并行或连续请求响应更快. 在 watch mode ,只有被修改的文件会从缓存中被剔除.如果 watch mode 关闭了,这些缓存将会在每次编译之前被清除. 可以看下 Resolve API 来了解更多 mentioned above 的配置选项. Fight Master all right reserved，powered by GitbookLatest Update 2020-06-03 15:28:18 "},"webpack/webpack-concept/8-module-federation.html":{"url":"webpack/webpack-concept/8-module-federation.html","title":"1.8 module","keywords":"","body":"Module Federation Motivation(动机) 应该从单一应用中进行多个分离构建. 这些分离构建彼此不必相互依赖,所以它们可以单独的被部署和构建. Low level concepts 我们区分local 和 remote 模块. local模块 是正常的模块,即当前构建的一部分. remote模块 不是当前构建的一部分,它来自于容器,在运行时被载入. 载入到远程模块被视为异步操作.当我们使用一个远程模块的时候,这个异步操作会被替代. 这出现在下一个组块载入操作系统中的时候. 没有组块正在载入操作系统,它是不可能使用远程模块的. 一个chunk 载入操作系统通常使用 import() 调用,但是 旧版结构像 require.ensure or require([...]) 也被支持. container 通过 container entry 来创建, container entry 公开异步访问到指定模块.这种公开访问分为 2个步骤: 异步载入这个模块. 同时评估这个模块. 步骤1 在 chunk 载入的期间完成,步骤 2在和其他(local/remote) 模块交叉评估的过程中完成. 这种方式下,从 local 到 remote 来(或者其他方式)来转换一个模块,评估顺序是不受影响的, 嵌套一个container是有可能的.Containers 可以从其他Containers使用模块. 容器之间的循环依赖也是可能的. Overriding Container 可以标记选定的 local模块成为 \"overridable\" (可被覆写的). Container 的消费者可以提供 \"overrides\" (方法重载),这可以让模块替换容器中的 override 模块组中的一个. 只要消费者提供 方法重载, Container 中的所有模块都可以使用可替换的模块,来替代 local module. 但消费者若不提供一个替换模块, Container中的所有模块将使用本地模块. Container 管理 override 模块, 这种方式是: 当模块通过消费者被覆写的时候,这些模块不需要被下载.通过在分离的chunk中来放置替换模块. 另外一方面,替换模块的提供者,只提供 异步载入函数.它允许 container 来载入替换模块(只是它们在需要的情况下). 提供者将会管理替换模块,它们不通过container请求,所以它们不必被下载.通过在分离的chunk中来放置替换模块. 一个 \"name\" 被用于校验来自 container 的覆写模块. 容器 exposes (公开) 模块的时候,以一种类似的方式提供覆写,分为两个步骤: loading (异步) evaluating (异步) 当嵌套使用的时候,在嵌套的containers中,给一个container提供覆写 将会自动覆写这些模块. 在容器中的模块被载入之前覆写必须被提供. 可覆盖对象在初始化 chunk 被使用,只可以通过同步模块覆写方式来进行覆盖.不能使用promise. 一旦评估,可覆盖对象就不能被覆写了. High-level concepts 每个构建动作都充当容器,消耗其他构建也会充当容器. 每一次构建,通过从它的容器载入,可以访问任何其他公开模块. Building blocks OverridablesPlugin [low level] 这个plugin 让指定的模块 \"override\". A local API (webpackoverride) 允许提供 overrides // webpack.config.js // ------------------------------------- const OverridablesPlugin = require('webpack/lib/container/OverridablesPlugin'); module.exports = { plugins: [ new OverridablesPlugin([ { // we define an overridable module with OverridablesPlugin test1: './src/test1.js', }, ]), ], }; // src/index.js // ------------------------------- __webpack_override__({ // here we override test1 module test1: () => 'I will override test1 module under src', }); ContainerPlugin[low level] ContainerReferencePlugin [low level] ModuleFederationPlugin[high level] Concept goals 应该尽可能的公开和使用webpack支持的任何模块类型 Chunk 载入的过程中应该载入并行过程需要的一切.(到服务器的单个往返) 从消费者到容器的控制 1.覆写模块是一个定向操作 2.Sibling Containers 不能覆写彼此间的其他模块. Concept 应该环境独立 1.可用的web,nodejs,etc Use Cases Separate builds per page 从容器里分离构建的单页面应用的每一页都是公开的. 这个应用shell也是作为remote module来分离构建引用所有的页面. 这样每一页都能被分别部署.这个应用shell通常使用库来定义,作为共享modules来避免页面构建中重复. Components library as container 很多应用共享一个 common components 库,这个库可以被构建成每个组件公开的container. 每个应用的消费组件来自于组件库容器. 改变组件库可以分别部署,而不需要重新发布应用.这个应用自动使用组件库的升级版本. Fight Master all right reserved，powered by GitbookLatest Update 2020-06-03 15:28:18 "},"webpack/webpack-concept/9-dependency-graph.html":{"url":"webpack/webpack-concept/9-dependency-graph.html","title":"1.9 dependency graph","keywords":"","body":"Dependency Graph 任意时间一个文件依赖于其他文件,webpack将其视为一个依赖.这允许webpack来携带非代码资产,比如说 images/web fonts,在应用上也可以提供他们作为依赖. 当webpack引导你的应用的时候,它从位于命令行或者它的配置文件的模块列表定义开始. 也就是从 entry point 开始,webpack 递归的构建依赖图示,这些图示包含应用中需要的每个模块,接下来将这些模块全部捆绑到少数捆绑包当中.浏览器通常只载入一次. 捆绑应用对于HTTP/1.1 client 相当牛逼,因为在浏览器开始一个新的请求的时候,它最小化了APP的等待时间, 对于 http/2,你可以使用代码切割 来实现比较好的结果. Fight Master all right reserved，powered by GitbookLatest Update 2020-06-03 15:28:18 "},"webpack/webpack-concept/10-target.html":{"url":"webpack/webpack-concept/10-target.html","title":"1.10 target","keywords":"","body":"Target 因为JS可以对所有服务器和浏览器写入,webpack提供了多个部署对象,你可以在你的webpack 配置里面设置. webpack target 属性不能和 output.libraryTarget 属性相混淆. Usage 要想设置 target 属性,需要在webpack config 里面简单设置 target 值: module.exports = { target: 'node' }; 使用 node webpack将会在NODEJS 环境下 编译使用. (使用 node.js 的require 将会载入 chunks 并不会触及任何内置于模块的内容. 比如: fs / path) 每个 target 有多重 部署/环境指定附加项,满足它的需要. Multi Targets 尽管webpack 不支持多行字符串 来传递 target 属性,你可以创建一个 同构(isomorphic) 库,使用两个分离的配置就可以做到: const path = require('path'); const serverConfig = { target: 'node', output: { path: path.resolve(__dirname, 'dist'), filename: 'lib.node.js' } //… }; const clientConfig = { target: 'web', // 上面的这个例子将会在 dist 文件中 创建 lib.js 和 lib.node.js . Resources 还有很多部署对象供你选择,你可以看下下面的例子 compare-webpack-target-bundles boilerplate of electron - react application Fight Master all right reserved，powered by GitbookLatest Update 2020-06-03 15:28:18 "},"webpack/webpack-concept/11-manifest.html":{"url":"webpack/webpack-concept/11-manifest.html","title":"1.11 manifest","keywords":"","body":"The Manifest(清单) 使用webpack构建一个典型应用/网站,这里面有三种类型的代码: 你自己的源代码. 第三方库的代码. 3.webpack的 runtime 和manifest,来指导所有模块的交互. Runtime runtime,处在 manifest data之间, 是webpack所有代码里的基本,当运行在浏览器中的时候,需要连接你的模块化应用. 它包含loading 和 resolving 逻辑 需要连接你的模块作为他们的交流. 这包含正在连接的模块,已经被载入到浏览当中,以及逻辑上的延迟加载那些没有连接的模块. Manifest 一旦你的应用在=index.html= 文件形式中,点击浏览器, 一些捆绑包和其他类型的assets会被应用需要,必须被载入和以某种方式链接. 你精心设置的 src 目录现在被捆绑,压缩,甚至可能通过webpack的 optimization 延迟加载 分割为更小的chunks. 那么webpack如何管理required 模块的彼此之间的交流哪?这就是为什么要谈到 manifest. 当编译入口,解析,并映射到应用,webpack 在所有的模块上面保持了详细的笔记. 这些收集的信息被称为 \"manifest\", 在运行时将使用解析和载入模块,一旦它们被捆绑和运送到浏览器当中. 无论你选择哪个模块语法,那些 =import= 或者 =require= 声明 现在变成 =__webpackl_require__= 方法(用于指向模块标识符) 使用manifest中的数据,runtime 将会找出从哪检索标识符后面的模块. The problem 现在你有一点关于webpack场景背后工作的一些见解. 但是它跟自己有毛关系哪? runtime webpack 做自己的事情,运用清单,每件事都将会发生,一旦你的应用点击了浏览器. 如果你想要提高你的项目的性能,比如通过运用浏览器缓存,这个进程突然成为一个需要理解的重要事情. 通过在你的 捆绑文件名中 运用content hash,当文件内容发生改变的时候,你可以指示浏览器缓存无效. 一旦你开始使用,你将立即注意到这些有趣的行为. 即便他们的内容没有明显的改变,某些hashes的也会改变. 这是由runtime的注入和每次构建改变的manifest 造成的 . TODO: extract the manifest caching Fight Master all right reserved，powered by GitbookLatest Update 2020-06-03 15:28:18 "},"webpack/webpack-concept/12-hot-modeule-replacement.html":{"url":"webpack/webpack-concept/12-hot-modeule-replacement.html","title":"1.12 HMR","keywords":"","body":"Hot module replacement Hot Module Replacement (HMR) exchange,adds,or removes module while an applications is running, without a full reload. This can sinigicantly speed up development in a few ways: 保持全部重载期间丢失的应用状态 更新改变的部分来节省宝贵的开发时间 当修改的部分放到源代码中的CSS/JS 的时候,浏览器立即更新.这个效果就像在浏览器 dev tools 直接改变style一样. How It works In the application 下面的步骤允许模块在应用之外交流: 应用询问HMR runtime 检查更新. runtime 异步下载更新并通知应用. 应用接下来询问 runtime 来apply 更新内容. runtime 同步应用更新. 你可以设置HMR 以便于这个进程自动发生,对于更新,你也可以选择 require 用户注入来产生. In the compiler 除了正常的 assets之外,编译器需要发出一个 \"update\" 来告诉先前版本到新版本允许更新. 这个 \"update\" 由 两部分组成: Updated manifest (JSON) 多个update chunk (JS) 这个 manifest 包含新的 compilation hash 和 所有update chunks的list. 每个chunk都含有全部更新模块的新代码.(或者是一个标识,来指示哪些模块被移除) 编译器确保模块的ID和chunk的IDs 和这些构建是一致的.通常编译器通常把这些IDs 存在内存当中.比如说(webpack-dev-server),但是也可能存在JSON file 当中. In a Module HMR是一个可选的功能,仅影响包含HMR code的模块. 一个很好的例子就是通过 style-loader 打补丁styling. 要想这个补丁正常工作, style-loader 实现了 HMR的 接口,当它通过HMR 接收到 update的时候,它将会用新的样式来替换旧的样式. 类似的,当在一个模块实现HMR接口的时候,你可以描述当模块更新的时候,什么应该发生. 但是,大多数情况下,并不强制在每个模块中写下HMR的代码. 如果一个模块没有HMR handlers,这个update就会略过. 这意味着单个 handler 可以更新一个完整的模块树.如果来自这个树的单个模块更新了,那么整个依赖集就会被重载. In the Runtime 对于模块系统的runtime,发出额外的代码来追踪 模块 parents 和 children.在管理方面,这个runtime支持两个方法: check 和 apply. check 让 http请求 来更新 manifest.如果请求失败了,更新无效.如果成功了,更新的chunks列表是不同于当前已经载入的chunks了. 对于每个已经载入的chunk,对应的更新chunk会被下载. 所有模块更新在runtime期间被存储.当所有更新的chunk下载完毕并准备应用的时候,runtime会跳转为 ready state. apply 方法标志所有更新的模块无效.对于每个无效的模块,它们需要在模块或者父级模块里面更新 handler. 否则,无效标识将会省略并且无视父级模块.每个都会省略,直到APP的入口点或者模块收到带有更新 handler. 如果从一个入口点被省略,那么这个进程就GG了. 之后所有无效的模块都会被处理(包含处理handler) 和 卸载. 当前的hash接下来会更新并且全部 accept 被调用的handlers. runtime 会跳转回 idle 状态,一切都将正常进行. Fight Master all right reserved，powered by GitbookLatest Update 2020-06-03 15:28:18 "},"webpack/webpack-concept/13-why-webpack.html":{"url":"webpack/webpack-concept/13-why-webpack.html","title":"1.13 why webpack","keywords":"","body":"Why webpack 使用一个物之前,先看下之前他们的面临的烂摊子. Thinking: 在浏览器运行JS有几个法? 每个功能都写一个脚本. 毛病 : 载入太多脚本,有网络问题 一个大JS文件. 毛病 : 维护,可读性,范围,大小问题. 立即调用函数表达式(IIFE) Js modules happened form node,js webpack runs on Node,js, a javascript runtime that can be used in computers and servers outside a browser environment. commonjs come out and introduced require,which allows you to load and use a module in the current file. This solved scope issues out of the box by importing each module as it was needed, Fight Master all right reserved，powered by GitbookLatest Update 2020-06-03 15:28:18 "},"webpack/webpack-concept/14-under-the-hoods.html":{"url":"webpack/webpack-concept/14-under-the-hoods.html","title":"1.14 under the hoods","keywords":"","body":"under the hooks 捆绑过程是一个带来一些文件和发射其他文件的函数. the mainparts index.js app.js 要是用它们,模块来自 ModuleGraph. 在捆绑进程期间,模块包含在chunks里面. Chunks包含在来自 通过模块互相连接 ChunkGraph 的 Chunk groups 里面. 当你描述一个入口点的时候,在hood之下,你创建了带有chunk的 chunk group. Chunks initial: entry: index.jsx / index.js | output: main.js | output.filename non-initial: output.chunkFilename [name] [contenthash] Fight Master all right reserved，powered by GitbookLatest Update 2020-06-03 15:28:18 "},"bash/READMD.html":{"url":"bash/READMD.html","title":"bash tutorial","keywords":"","body":"power unix tools bash tutorial. 在这里我想在MARKDOWN里面使用文学编程.但是一一失败了. 我尝试了R MARKWON PYTHON MARKDOWN,都不行. 没有办法,我只能再次跳转回ORG MODE. 由于GITBOOK只支持MARKDOWN格式,所有我只能手动让其生成MARKDOWN文件了. 然后再集成MERMAID,插入HTML.应该不会有太大问题. 最终我测试成功了. test include html file !INCLUDE \"./html/test.html\" !INCLUDE \"./html/mermaid.html\" Fight Master all right reserved，powered by GitbookLatest Update 2020-06-15 19:13:29 "},"bash/shell-command.html":{"url":"bash/shell-command.html","title":"1.1 shell command","keywords":"","body":"Shell Command Pipelines 一个 pipeline 是一个或者多个通过控制运算符 | or |& 分开的序列. pipeline 的格式如下: [time [-p]] [!] command1 [ | or |& command2 ] ... 在pipeline中每个命令的输出通过管道被关联到下一个命令的输入.每个命令读 取上一个命令的输出.这个连接会在命令指定任何重定向之前会被执行. 如果 |& 被用过了, command1的标准error,会附加到它标准输出上去,通过 这个管道连接到 command2 的标准输入. 它是 2>&1 | 的简写. 标准 error 到标准 output 的隐式重定向会在命令指定任何重定向之后被执行. 传输管道一旦完成,保留字 time 时间统计就会被打印.统计当前包括(挂钟) 时间,用户,系统时间通过命令执行消耗的时间. -p 选项改变输出为POSIX指 定的格式.当SHELL是 POSIX mode 的时候,如果下一个 token 以 a 开头, 它将不会将 time 视为保留字. TIMEFORMAT 变量可能会设置一个格式字符 串来指定 timing 信息如何被展示. bash variable 里有更加详细的描述.允 许SHELL内置,shell函数,管道的计时使用time 作为保留字,外部的time 命 令不会轻易的计时. 当SHELL处于POSIX MODE的时候, time 后面可能会带着换行符.在这种情况 下,SHELL通过shell和它的children展示整个user和system消耗的时间. TIMEFORMAT 变量被用来指定 time information的格式. 如果管道不是asynchronously执行,shell会等着管道里所有命令执行完毕. 管道里的每个命令会在它自己的subshell被执行,这是一个分离的过程,如果 lastpipe选项使用内置命令shopt开启,管道的最后的一个元素可以由shell 进程运行. 除非pipefail 被开启.管道的 exit status 是管道中最后一个命令的 exit status.如果pipefail是开启状态,管道的返回状态是最后(最右侧)命 令以非零状态退出的值,如果所有命令退出成功,管道的返回状态就是0.如果保留 字 ! 先于管道之前, exit status 与上面 exit status描述相反.shell 等着管道中的所有命令在返回值之前终止. More Information shell脚本中,默认情况下,总是有三个文件处于打开状态,分别是: - 标准输入 (默认键盘输入,文件描述符为0) - 标准输出 (默认屏幕输出,文件描述符为1) - 标准错误 (默认屏幕输出,文件描述符为2) > 默认为标准输出重定向,与 1> 相同. 2>&1 将标准错误输出重定向到标准输. &>file 将标准输出和标准错误输出都重定向文件file当中. /dev/null是一个文件,所有传递给它的文件都会被丢弃掉. TEXT DEMO Welcome to plain text world! Scene: 当前目录只有一个文件 a.txt 1.测试 1 and 2 输出 [revolt@Remake ~]$ ls a.txt b.txt ls: cannot access 'b.txt': No such file or directory a.txt 由于没有 b.txt 这个文件,所以就会返回错误值.也就是标准错误输出(2输出). a.txt 由于存在,所以就是标准输出(1输出). 2.理解 \"1>&2\" 和 \"2>&1\" 所谓 1> 可以简写成为 >. 所以可以简写成为 1>&2 正确返回值传递给2输出通道, &2表示2输出通道. 2>&1 错误返回值传递给1输出通道, &1表示1输出通道. 2.1 测试错误返回值传递 此时将错误返回值,通过2标准错误输出 传递到 1标准输出里. 2.2 直接将正确和错误的返回值都写到文件当中 Fight Master all right reserved，powered by GitbookLatest Update 2020-06-15 16:02:50 "},"bash/content/1-basic-bash.html":{"url":"bash/content/1-basic-bash.html","title":"1.2 bash basic","keywords":"","body":"+++ title = \"BASH BASIC\" lastmod = 2020-06-17T09:38:58+08:00 draft = false +++ -- mode: Org; org-download-image-dir: \"~/.emacs.d/lisp/private/gitbook/assets/screenshot/\"; -- Getting Bash check your current use bash type echo $SHELL /usr/bin/zsh check bash path whereis bash bash: /usr/bin/bash /usr/lib/bash /etc/bash.bashrc /etc/bash.bash_logout /usr/include/bash /usr/share/man/man1/bash.1.gz /usr/share/info/bash.info.gz which bash /usr/bin/bash whence bash /usr/bin/bash change current defualt shell # chsh /usr/bin/bash Interactive Shell Use Commands,Arguments,and Options Shell 命令行有一个或者多个word组成,通过BLANKS或者TABS来进行分隔.组 成格式如下: command auguments/parameters Files File是任何UNIX系统中最重要的类型.一个File可以包含各种各样的信息,同 样也有不同类型的File.主要有三种最重要的类型: Regular files(常规文件) : text files. Executable files(可执行文件) : The shell itself is a executable file called bash. Directories(目录) : like folders that contain other files. Directories Directories can contain other directories leads to a hierachical structure. directories tree The working directory You need to specify a file path,then you should have a work directory,then should use relative path. When you log in to the system,your working directory is initially set to a special directory called your home directory. 系统管理员经常设置系统,所有每个人的HOME目录名字都跟他们的登录名字 相同,所有的HOME目录都被包含在root之下的同一个目录内. Tilde notation (~) 1.run org-babel-tangle generate hello.txt file in /home/revolt (your user ditrectory). 结婚没意思 2.你可以在用户 revolt HOME 目录下引用一个file hello.写法如下: #!/bin/bash ls -ll ~revolt/hello.txt -rw-r--r-- 1 root root 16 Jun 17 09:38 /home/revolt/hello.txt 这是一种绝对路径,当你使用它的时候,你不必在乎它的working directory. 更加方便的是, ~ 本身就是引用到你自己的 home 目录. #!/bin/bash ls -ll ~/ #!/bin/bash ls -ll /home/revolt 注意下 ~hello.txt 与 ~/hello.txt 的区别. [revolt@Remake ~]$ cat ~revolt/hello.txt 结婚没意思 [revolt@Remake ~]$ cat ~/hello.txt 结婚没意思 [revolt@Remake ~]$ cat ~hello.txt cat: '~hello.txt': No such file or directory # in here, ~hello.txt is user hello.txt's home directory. Changing working directories Just input cd in terminal, you will go to your home directory. Filenames,Wildcards,and Pathname Expansion Wildcard Matches ? Any Single Character * Any String of Character [set] Any character in set [!set] Any character not in set ls hello???? hello.asd hello.txt ls hello* hello.asd hello.txt Remake➜ test : master ✘ :✖✹✭ ᐅ ls -al total 20 drwxr-xr-x 5 revolt revolt 4096 Jun 15 23:11 . drwxr-xr-x 12 revolt revolt 4096 Jun 15 21:41 .. drwxr-xr-x 2 revolt revolt 4096 Jun 15 19:41 bash drwxr-xr-x 2 revolt revolt 4096 Jun 15 23:11 cash drwxr-xr-x 3 revolt revolt 4096 Jun 15 17:54 pweave_demo Remake➜ test : master ✘ :✖✹✭ ᐅ tree [bc]ash # here test demo bash ├── 1.txt ├── file.err └── file.out cash 0 directories, 3 files Remake➜ test : master ✘ :✖✹✭ ᐅ echo {a,b,c{a,c,d}} a b ca cc cd Pipelines 需要弄清楚, 1.何时需要把结果输出到一个文件里? 2.何时需要重定向 一个命令的输出 作为 其他命令的输入? 2描述的这种操作可以称为 pipe.(管道),本质上是个传递操作,符号记做 |. 比如: 在使用 ls -l 的时候,如果你的文件太多,还没来得及一一浏览,就 一闪而过了.此时,你可以使用 ls -ll | more 来进行预览. The file /etc/passwd stores information about user's accounts on a UNIX system. main have login name,user ID number,encryted passwd,home directory,login shell. bat /etc/passwd 想得到当前系统经过排序的所有用户, # cut command extracts the first field (-f1) cut -d: -f1 avahi bin colord cups daemon dbus dhcpcd ftp git http mail mysql nobody ntp nvidia-persistenced polkitd revolt root rtkit sddm systemd-coredump systemd-journal-remote systemd-network systemd-resolve systemd-timesync tor usbmux uuidd cut command cut --help generate a test file demo1.txt No;Name;Mark;Percent 01 tom 69 91 02 jack 71 87 03 alex 68 98 现在我们想选出 demo1.txt 中的第一行的 Name;Mark 字段. 1.我们第一步清洗出带有 Name;Mark 的所有字段. #! /bin/bash cut -d \";\" -f 2,3 demo1.txt # cut -d \";\" -f 2- demo1.txt # print the second field to end of line # ref link: https://www.jianshu.com/p/b5541da98139 2.利用stream editor选出第一行,管道操作一下. #! /bin/bash sed -n \"1p\" demo1.txt | cut -d \";\" -f 1,2 # print line 1 to end of line # sed -n '2,$p' demo1.txt # 注意这里一定要使用单引号 # ref link: https://blog.csdn.net/lantianjialiang/article/details/52042135 Fight Master all right reserved，powered by GitbookLatest Update 2020-06-17 09:38:58 "},"bash/content/2-bash-heredoc.html":{"url":"bash/content/2-bash-heredoc.html","title":"1.3 bash basic","keywords":"","body":"+++ title = \"BASH Heredoc\" lastmod = 2020-06-20T17:22:55+08:00 draft = false +++ -- mode: Org; org-download-image-dir: \"~/.emacs.d/lisp/private/gitbook/assets/screenshot/\"; -- 当你写shell脚本的时候你可能会在某个位置传递多行文本块或者代码给一个交 互的命令,比如 tee or cat, or sftp Heredoc Syntax [COMMAND] 第一行始于一个可选COMMAND,后面跟着特殊的重定向运算符 和 delimiting identifier. 你可以将任何字符串作为 delimiting identifier,最常用的是 EOF 和 END. 如果 delimiting identifier 没有引号,在传递 here-document 行给 命令之前,shell会替换所有 variable,command 和 sepcial character. 附加一个 - 到重定向运算符 , 将会让所有主要的tab字符被忽 略.当在SHELL脚本里面写 here-document 的时候允许你使用 indentation . Leading whitespace characters are not allowed,only tab. here-document 块可以包含 strings, variables, commands 和 其他类 型的输入. The last line ends with the delimiting identifier.White space in front of the delimiter is not allowed. Basic Demo cat 此时所有的命令输出和变量输出都会被传递. Demo2 cat 此时所有的命令输出和变量输出不会被传递. Demo3 如果你正在一个statement or loop里面使用 heredoc,使用 重定向 运算符允许你缩进您的代码. a=0 cat 在这里你不能使用空格来缩进代码,必须使用TAB来进行缩进,bash里面的TAB 需要按下 C-v TAB 来插入.并非简单的 TAB 缩进. reflink: https://stackoverflow.com/questions/18660798/here-document-gives-unexpected-end-of-file-error #! /bin/bash if true; then cat Demo4 将 heredocument 输出到屏幕的内容重定向到一个文件当中. #! /bin/bash if true; then cat ./test.sh This is a TAB indented. EOF fi cat test.sh This is a TAB indented. Demo5 heredocument 的内容与 Pipe 一齐使用. Fight Master all right reserved，powered by GitbookLatest Update 2020-06-20 17:22:56 "},"default.html":{"url":"default.html","title":"Yet another page","keywords":"","body":"NIce Day 每一天都是崭新的开始 Fight Master all right reserved，powered by GitbookLatest Update 2020-06-03 15:28:18 "}}